generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum VerificationStatus {
  PENDING
  CRAWLING
  AWAITING_ADMIN
  APPROVED
  DENIED
  EXPIRED
}

enum UserRole {
  USER
  ARTIST
  ADMIN
  SUPER_ADMIN
}

enum MessageType {
  TEXT
  TRACK_CARD
  SYSTEM
  REPLY
}

enum ModerationAction {
  DELETE_MESSAGE
  MUTE_USER
  CLEAR_REACTIONS
}

model User {
  id                    String                 @id @default(uuid())
  email                 String                 @unique
  supabaseId           String                 @unique @map("supabase_id")
  role                 UserRole               @default(USER)
  createdAt            DateTime               @default(now()) @map("created_at")
  updatedAt            DateTime               @updatedAt @map("updated_at")
  
  artistProfile        ArtistProfile?
  verificationRequests VerificationRequest[]
  reviewedVerifications VerificationRequest[] @relation("ReviewedVerifications")
  adminActions         AdminAction[]
  
  // Chat relations
  messages             Message[]
  reactions            Reaction[]
  roomMemberships      RoomMembership[]
  mutedUntil           DateTime? @map("muted_until")

  // Wave A relations
  profile              Profile?

  @@map("users")
}

model ArtistProfile {
  id           String   @id @default(uuid())
  userId       String   @unique @map("user_id")
  artistName   String   @map("artist_name")
  bio          String?
  verified     Boolean  @default(false)
  verifiedAt   DateTime? @map("verified_at")
  websiteUrl   String?  @map("website_url")
  spotifyUrl   String?  @map("spotify_url")
  bandcampUrl  String?  @map("bandcamp_url")
  soundcloudUrl String? @map("soundcloud_url")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([verified])
  @@index([artistName])
  @@map("artist_profiles")
}

model VerificationRequest {
  id              String             @id @default(uuid())
  userId          String             @map("user_id")
  claimCode       String             @unique @map("claim_code")
  targetUrl       String?            @map("target_url")
  status          VerificationStatus @default(PENDING)
  submittedAt     DateTime           @default(now()) @map("submitted_at")
  expiresAt       DateTime           @map("expires_at")
  crawledAt       DateTime?          @map("crawled_at")
  reviewedAt      DateTime?          @map("reviewed_at")
  reviewedBy      String?            @map("reviewed_by")
  denialReason    String?            @map("denial_reason")
  crawlerResponse Json?              @map("crawler_response")
  metadata        Json?

  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  reviewer User?  @relation("ReviewedVerifications", fields: [reviewedBy], references: [id])

  @@index([status])
  @@index([userId])
  @@index([claimCode])
  @@index([expiresAt])
  @@map("verification_requests")
}

model AdminAction {
  id          String   @id @default(uuid())
  adminId     String   @map("admin_id")
  action      String
  targetId    String?  @map("target_id")
  targetType  String?  @map("target_type")
  details     Json?
  ipAddress   String?  @map("ip_address")
  userAgent   String?  @map("user_agent")
  createdAt   DateTime @default(now()) @map("created_at")

  admin User @relation(fields: [adminId], references: [id])

  @@index([adminId])
  @@index([targetId])
  @@index([createdAt])
  @@map("admin_actions")
}

model CrawlerCache {
  id         String   @id @default(uuid())
  url        String   @unique
  content    String?
  statusCode Int?     @map("status_code")
  headers    Json?
  crawledAt  DateTime @default(now()) @map("crawled_at")
  expiresAt  DateTime @map("expires_at")

  @@index([url])
  @@index([expiresAt])
  @@map("crawler_cache")
}

// Chat Models

model Room {
  id           String   @id @default(uuid())
  name         String
  description  String?
  isPrivate    Boolean  @default(false) @map("is_private")
  createdBy    String   @map("created_by")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  
  messages     Message[]
  memberships  RoomMembership[]

  @@index([isPrivate])
  @@index([createdAt])
  @@map("rooms")
}

model RoomMembership {
  id       String   @id @default(uuid())
  roomId   String   @map("room_id")
  userId   String   @map("user_id")
  isMod    Boolean  @default(false) @map("is_mod")
  joinedAt DateTime @default(now()) @map("joined_at")
  
  room Room @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([roomId, userId])
  @@index([roomId])
  @@index([userId])
  @@map("room_memberships")
}

model Message {
  id        String      @id @default(uuid())
  roomId    String      @map("room_id")
  userId    String      @map("user_id")
  type      MessageType @default(TEXT)
  text      String?
  trackRef  Json?       @map("track_ref")
  parentId  String?     @map("parent_id")
  createdAt DateTime    @default(now()) @map("created_at")
  updatedAt DateTime    @updatedAt @map("updated_at")
  deletedAt DateTime?   @map("deleted_at")
  
  room      Room        @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent    Message?    @relation("MessageReplies", fields: [parentId], references: [id])
  replies   Message[]   @relation("MessageReplies")
  reactions Reaction[]

  @@index([roomId, createdAt])
  @@index([userId])
  @@index([parentId])
  @@index([deletedAt])
  @@map("messages")
}

model Reaction {
  id        String   @id @default(uuid())
  messageId String   @map("message_id")
  userId    String   @map("user_id")
  emoji     String
  createdAt DateTime @default(now()) @map("created_at")
  
  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@index([userId])
  @@map("reactions")
}

model TrackRef {
  id         String   @id @default(uuid())
  provider   String   // spotify, apple, youtube, bandcamp, beatport
  providerId String   @map("provider_id")
  url        String   @unique
  title      String
  artist     String
  artwork    String?
  duration   Int?     // in seconds
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")
  
  @@unique([provider, providerId])
  @@index([provider])
  @@index([url])
  @@map("track_refs")
}

// Wave A Models - Profiles & Playlists

model Profile {
  id          String   @id @default(uuid())
  userId      String   @unique @map("user_id")
  username    String   @unique
  displayName String?  @map("display_name")
  bio         String?
  avatarUrl   String?  @map("avatar_url")

  // Onboarding fields
  genres              String[] @default([])
  genresCompleted     Boolean  @default(false) @map("genres_completed")
  genresCompletedAt   DateTime? @map("genres_completed_at")

  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  user                User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  ownedPlaylists      Playlist[]             @relation("PlaylistOwner")
  playlistCollaborations PlaylistCollaborator[]
  addedPlaylistItems  PlaylistItem[]

  @@index([username])
  @@index([genresCompleted])
  @@map("profiles")
}

model Playlist {
  id              String   @id @default(uuid())
  ownerUserId     String   @map("owner_user_id")
  title           String
  description     String?
  isPublic        Boolean  @default(true) @map("is_public")
  isCollaborative Boolean  @default(false) @map("is_collaborative")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  owner        Profile                @relation("PlaylistOwner", fields: [ownerUserId], references: [userId], onDelete: Cascade)
  items        PlaylistItem[]
  collaborators PlaylistCollaborator[]

  @@index([ownerUserId])
  @@index([isPublic])
  @@map("playlists")
}

model PlaylistCollaborator {
  playlistId String   @map("playlist_id")
  userId     String   @map("user_id")
  role       String   @default("contributor") // contributor, editor, owner
  addedAt    DateTime @default(now()) @map("added_at")

  playlist Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  profile  Profile  @relation(fields: [userId], references: [userId], onDelete: Cascade)

  @@id([playlistId, userId])
  @@map("playlist_collaborators")
}

model PlaylistItem {
  id               String   @id @default(uuid())
  playlistId       String   @map("playlist_id")
  position         Int
  provider         String   // spotify, apple, beatport, youtube, etc.
  providerTrackId  String   @map("provider_track_id")
  title            String?  // optional denormalization
  artist           String?  // optional denormalization
  artworkUrl       String?  @map("artwork_url")
  addedByUserId    String   @map("added_by_user_id")
  addedAt          DateTime @default(now()) @map("added_at")

  playlist  Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  addedBy   Profile  @relation(fields: [addedByUserId], references: [userId], onDelete: Cascade)

  @@unique([playlistId, position])
  @@index([playlistId])
  @@index([addedByUserId])
  @@map("playlist_items")
}

model ModerationLog {
  id         String           @id @default(uuid())
  roomId     String           @map("room_id")
  moderatorId String          @map("moderator_id")
  targetId   String           @map("target_id") // message or user id
  action     ModerationAction
  reason     String?
  createdAt  DateTime         @default(now()) @map("created_at")
  
  @@index([roomId])
  @@index([moderatorId])
  @@index([targetId])
  @@index([createdAt])
  @@map("moderation_logs")
}