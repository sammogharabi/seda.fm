generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum VerificationStatus {
  PENDING
  CRAWLING
  AWAITING_ADMIN
  APPROVED
  DENIED
  EXPIRED
}

enum UserRole {
  USER
  ARTIST
  ADMIN
  SUPER_ADMIN
}

enum MessageType {
  TEXT
  TRACK_CARD
  SYSTEM
  REPLY
  PRODUCT_CARD
}

enum RoomMemberRole {
  MEMBER
  ADMIN
}

enum ModerationAction {
  DELETE_MESSAGE
  MUTE_USER
  CLEAR_REACTIONS
}

model User {
  id                    String                 @id @default(uuid())
  email                 String                 @unique
  supabaseId           String                 @unique @map("supabase_id")
  role                 UserRole               @default(USER)
  createdAt            DateTime               @default(now()) @map("created_at")
  updatedAt            DateTime               @updatedAt @map("updated_at")

  // Email verification
  emailVerified        Boolean                @default(false) @map("email_verified")
  emailVerificationToken String?              @unique @map("email_verification_token")
  emailVerificationTokenExpiresAt DateTime?  @map("email_verification_token_expires_at")
  userType             String?                @map("user_type") // 'fan' or 'artist'

  artistProfile        ArtistProfile?
  verificationRequests VerificationRequest[]
  reviewedVerifications VerificationRequest[] @relation("ReviewedVerifications")
  adminActions         AdminAction[]

  // Chat relations
  createdRooms         Room[]             @relation("RoomCreator")
  messages             Message[]
  reactions            Reaction[]
  roomMemberships      RoomMembership[]
  sentRoomInvites      RoomInvite[]       @relation("RoomInviter")
  receivedRoomInvites  RoomInvite[]       @relation("RoomInvitee")
  mutedUntil           DateTime?          @map("muted_until")

  // Wave A relations
  profile              Profile?

  // DJ Session relations
  hostedSessions       DJSession[] @relation("SessionHost")
  djSessions           DJSession[] @relation("CurrentDJ")

  // Marketplace relations
  products             MarketplaceProduct[] @relation("ArtistProducts")
  purchases            Purchase[]           @relation("UserPurchases")
  revenueRecords       ArtistRevenue[]      @relation("ArtistRevenue")
  analytics            ArtistAnalytics[]    @relation("ArtistAnalytics")
  fans                 FanEngagement[]      @relation("ArtistFans")
  fanEngagements       FanEngagement[]      @relation("FanEngagements")

  // Streaming service connections
  streamingConnections StreamingConnection[]

  // Payout relations
  payouts              ArtistPayout[]       @relation("ArtistPayouts")

  // Shopify connection
  shopifyConnection    ShopifyConnection?

  // Merch drops
  drops                MerchDrop[]

  @@index([emailVerified])
  @@index([createdAt])
  @@map("users")
}

model ArtistProfile {
  id           String   @id @default(uuid())
  userId       String   @unique @map("user_id")
  artistName   String   @map("artist_name")
  bio          String?
  verified     Boolean  @default(false)
  verifiedAt   DateTime? @map("verified_at")
  websiteUrl   String?  @map("website_url")
  spotifyUrl   String?  @map("spotify_url")
  bandcampUrl  String?  @map("bandcamp_url")
  soundcloudUrl String? @map("soundcloud_url")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // AI Detection & Trust
  trustedUploader     Boolean  @default(false) @map("trusted_uploader")
  trustedUploaderSince DateTime? @map("trusted_uploader_since")
  uploadCount         Int      @default(0) @map("upload_count")
  verifiedUploadCount Int      @default(0) @map("verified_upload_count")

  // Stripe Connect for payouts
  stripeAccountId     String?  @map("stripe_account_id")
  stripeAccountStatus String?  @map("stripe_account_status") // pending, active, restricted

  // PayPal for payouts
  paypalEmail         String?  @map("paypal_email")
  paypalMerchantId    String?  @map("paypal_merchant_id")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([verified])
  @@index([artistName])
  @@index([stripeAccountId])
  @@map("artist_profiles")
}

model VerificationRequest {
  id              String             @id @default(uuid())
  userId          String             @map("user_id")
  claimCode       String             @unique @map("claim_code")
  targetUrl       String?            @map("target_url")
  status          VerificationStatus @default(PENDING)
  submittedAt     DateTime           @default(now()) @map("submitted_at")
  expiresAt       DateTime           @map("expires_at")
  crawledAt       DateTime?          @map("crawled_at")
  reviewedAt      DateTime?          @map("reviewed_at")
  reviewedBy      String?            @map("reviewed_by")
  denialReason    String?            @map("denial_reason")
  crawlerResponse Json?              @map("crawler_response")
  metadata        Json?

  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  reviewer User?  @relation("ReviewedVerifications", fields: [reviewedBy], references: [id])

  @@index([status])
  @@index([userId])
  @@index([claimCode])
  @@index([expiresAt])
  @@map("verification_requests")
}

model AdminAction {
  id          String   @id @default(uuid())
  adminId     String   @map("admin_id")
  action      String
  targetId    String?  @map("target_id")
  targetType  String?  @map("target_type")
  details     Json?
  ipAddress   String?  @map("ip_address")
  userAgent   String?  @map("user_agent")
  createdAt   DateTime @default(now()) @map("created_at")

  admin User @relation(fields: [adminId], references: [id])

  @@index([adminId])
  @@index([targetId])
  @@index([createdAt])
  @@map("admin_actions")
}

model CrawlerCache {
  id         String   @id @default(uuid())
  url        String   @unique
  content    String?
  statusCode Int?     @map("status_code")
  headers    Json?
  crawledAt  DateTime @default(now()) @map("crawled_at")
  expiresAt  DateTime @map("expires_at")

  @@index([url])
  @@index([expiresAt])
  @@map("crawler_cache")
}

// Chat Models

model Room {
  id             String   @id @default(uuid())
  name           String
  description    String?
  isPrivate      Boolean  @default(false) @map("is_private")
  genre          String?
  coverImageUrl  String?  @map("cover_image_url")
  createdBy      String   @map("created_by")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  creator        User     @relation("RoomCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  messages       Message[]
  memberships    RoomMembership[]
  invites        RoomInvite[]
  djSessions     DJSession[]

  @@index([isPrivate])
  @@index([createdAt])
  @@index([createdBy])
  @@map("rooms")
}

model RoomMembership {
  id       String           @id @default(uuid())
  roomId   String           @map("room_id")
  userId   String           @map("user_id")
  role     RoomMemberRole   @default(MEMBER)
  joinedAt DateTime         @default(now()) @map("joined_at")

  room Room @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([roomId, userId])
  @@index([roomId])
  @@index([userId])
  @@map("room_memberships")
}

model RoomInvite {
  id        String           @id @default(uuid())
  roomId    String           @map("room_id")
  inviterId String           @map("inviter_id")
  inviteeId String           @map("invitee_id")
  status    InviteStatus     @default(PENDING)
  createdAt DateTime         @default(now()) @map("created_at")
  expiresAt DateTime?        @map("expires_at")

  room    Room @relation(fields: [roomId], references: [id], onDelete: Cascade)
  inviter User @relation("RoomInviter", fields: [inviterId], references: [id], onDelete: Cascade)
  invitee User @relation("RoomInvitee", fields: [inviteeId], references: [id], onDelete: Cascade)

  @@unique([roomId, inviteeId])
  @@index([roomId])
  @@index([inviteeId])
  @@index([status])
  @@map("room_invites")
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

model Message {
  id        String      @id @default(uuid())
  roomId    String      @map("room_id")
  userId    String      @map("user_id")
  type      MessageType @default(TEXT)
  text      String?
  trackRef  Json?       @map("track_ref")
  productId String?     @map("product_id") // For PRODUCT_CARD messages
  parentId  String?     @map("parent_id")
  createdAt DateTime    @default(now()) @map("created_at")
  updatedAt DateTime    @updatedAt @map("updated_at")
  deletedAt DateTime?   @map("deleted_at")

  room      Room        @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent    Message?    @relation("MessageReplies", fields: [parentId], references: [id])
  replies   Message[]   @relation("MessageReplies")
  reactions Reaction[]
  product   MarketplaceProduct? @relation(fields: [productId], references: [id], onDelete: SetNull)

  @@index([roomId, createdAt])
  @@index([userId])
  @@index([parentId])
  @@index([deletedAt])
  @@index([productId])
  @@map("messages")
}

model Reaction {
  id        String   @id @default(uuid())
  messageId String   @map("message_id")
  userId    String   @map("user_id")
  emoji     String
  createdAt DateTime @default(now()) @map("created_at")
  
  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@index([userId])
  @@map("reactions")
}

model TrackRef {
  id         String   @id @default(uuid())
  provider   String   // spotify, apple, youtube, bandcamp, beatport
  providerId String   @map("provider_id")
  url        String   @unique
  title      String
  artist     String
  artwork    String?
  duration   Int?     // in seconds
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")
  
  @@unique([provider, providerId])
  @@index([provider])
  @@index([url])
  @@map("track_refs")
}

// Wave A Models - Profiles & Playlists

model Profile {
  id          String   @id @default(uuid())
  userId      String   @unique @map("user_id")
  username    String   @unique
  displayName String?  @map("display_name")
  bio         String?
  avatarUrl   String?  @map("avatar_url")

  // Onboarding fields
  genres              String[] @default([])
  genresCompleted     Boolean  @default(false) @map("genres_completed")
  genresCompletedAt   DateTime? @map("genres_completed_at")

  // Artist profile customization fields
  coverImage          String?  @map("cover_image")
  location            String?  // e.g., "Brooklyn, NY"
  photos              Json?    // Array of {id, url, caption}
  videos              Json?    // Array of {id, url, title, thumbnail}

  // Highlighted content (JSON arrays)
  highlightedTracks    Json? @map("highlighted_tracks")    // Array of track refs
  highlightedMerch     Json? @map("highlighted_merch")     // Array of product refs
  highlightedConcerts  Json? @map("highlighted_concerts")  // Array of concert refs

  // Social links (additional to ArtistProfile)
  instagramUrl        String?  @map("instagram_url")
  youtubeUrl          String?  @map("youtube_url")
  websiteUrl          String?  @map("website_url")

  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  user                User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  ownedPlaylists      Playlist[]             @relation("PlaylistOwner")
  playlistCollaborations PlaylistCollaborator[]
  addedPlaylistItems  PlaylistItem[]

  // Social Feed Relations
  posts          Post[]    @relation("UserPosts")
  comments       Comment[] @relation("UserComments")
  likes          Like[]    @relation("UserLikes")
  reposts        Repost[]  @relation("UserReposts")
  following      Follow[]  @relation("Following")
  followers      Follow[]  @relation("Followers")

  // Progression Relations
  progression    UserProgression? @relation("UserProgressionProfile")
  badgeUnlocks   UserBadge[]      @relation("UserBadgeProfile")

  @@index([username])
  @@index([genresCompleted])
  @@map("profiles")
}

model Playlist {
  id              String   @id @default(uuid())
  ownerUserId     String   @map("owner_user_id")
  title           String
  description     String?
  isPublic        Boolean  @default(true) @map("is_public")
  isCollaborative Boolean  @default(false) @map("is_collaborative")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Crate social features
  coverImageUrl String?  @map("cover_image_url")
  genre         String?
  mood          String?
  tags          String[] @default([])
  playCount     Int      @default(0) @map("play_count")

  owner        Profile                @relation("PlaylistOwner", fields: [ownerUserId], references: [userId], onDelete: Cascade)
  items        PlaylistItem[]
  collaborators PlaylistCollaborator[]

  // Social relations
  posts         Post[]  @relation("CratePosts")
  likes         Like[]  @relation("CrateLikes")

  @@index([ownerUserId])
  @@index([isPublic])
  @@map("playlists")
}

model PlaylistCollaborator {
  playlistId String   @map("playlist_id")
  userId     String   @map("user_id")
  role       String   @default("contributor") // contributor, editor, owner
  addedAt    DateTime @default(now()) @map("added_at")

  playlist Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  profile  Profile  @relation(fields: [userId], references: [userId], onDelete: Cascade)

  @@id([playlistId, userId])
  @@map("playlist_collaborators")
}

model PlaylistItem {
  id               String   @id @default(uuid())
  playlistId       String   @map("playlist_id")
  position         Int
  provider         String   // spotify, apple, beatport, youtube, etc.
  providerTrackId  String   @map("provider_track_id")
  title            String?  // optional denormalization
  artist           String?  // optional denormalization
  artworkUrl       String?  @map("artwork_url")
  addedByUserId    String   @map("added_by_user_id")
  addedAt          DateTime @default(now()) @map("added_at")

  playlist  Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  addedBy   Profile  @relation(fields: [addedByUserId], references: [userId], onDelete: Cascade)

  @@unique([playlistId, position])
  @@index([playlistId])
  @@index([addedByUserId])
  @@map("playlist_items")
}

model ModerationLog {
  id         String           @id @default(uuid())
  roomId     String           @map("room_id")
  moderatorId String          @map("moderator_id")
  targetId   String           @map("target_id") // message or user id
  action     ModerationAction
  reason     String?
  createdAt  DateTime         @default(now()) @map("created_at")

  @@index([roomId])
  @@index([moderatorId])
  @@index([targetId])
  @@index([createdAt])
  @@map("moderation_logs")
}

// Social Feed Models

enum PostType {
  TEXT
  TRACK
  CRATE
  MEDIA
  PRODUCT
}

model Post {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  type      PostType
  content   String?  // Text content
  trackRef  Json?    @map("track_ref") // Track metadata if type=TRACK
  crateId   String?  @map("crate_id")  // If type=CRATE
  mediaUrls String[] @map("media_urls") // If type=MEDIA
  productId String?  @map("product_id") // If type=PRODUCT

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at")

  user      Profile  @relation("UserPosts", fields: [userId], references: [userId], onDelete: Cascade)
  crate     Playlist? @relation("CratePosts", fields: [crateId], references: [id], onDelete: SetNull)
  product   MarketplaceProduct? @relation("ProductPosts", fields: [productId], references: [id], onDelete: SetNull)
  comments  Comment[]
  likes     Like[]
  reposts   Repost[]

  @@index([userId, createdAt])
  @@index([type])
  @@index([deletedAt])
  @@index([productId])
  @@map("posts")
}

model Comment {
  id        String    @id @default(uuid())
  postId    String    @map("post_id")
  userId    String    @map("user_id")
  parentId  String?   @map("parent_id") // For threading
  content   String

  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at")

  post      Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      Profile   @relation("UserComments", fields: [userId], references: [userId], onDelete: Cascade)
  parent    Comment?  @relation("CommentReplies", fields: [parentId], references: [id])
  replies   Comment[] @relation("CommentReplies")
  likes     Like[]

  @@index([postId, createdAt])
  @@index([userId])
  @@index([parentId])
  @@map("comments")
}

enum LikeableType {
  POST
  COMMENT
  CRATE
}

model Like {
  id        String       @id @default(uuid())
  userId    String       @map("user_id")
  type      LikeableType
  postId    String?      @map("post_id")
  commentId String?      @map("comment_id")
  crateId   String?      @map("crate_id")

  createdAt DateTime     @default(now()) @map("created_at")

  user      Profile      @relation("UserLikes", fields: [userId], references: [userId], onDelete: Cascade)
  post      Post?        @relation(fields: [postId], references: [id], onDelete: Cascade)
  comment   Comment?     @relation(fields: [commentId], references: [id], onDelete: Cascade)
  crate     Playlist?    @relation("CrateLikes", fields: [crateId], references: [id], onDelete: Cascade)

  @@unique([userId, type, postId])
  @@unique([userId, type, commentId])
  @@unique([userId, type, crateId])
  @@index([postId])
  @@index([commentId])
  @@index([crateId])
  @@map("likes")
}

model Repost {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  postId    String   @map("post_id")

  createdAt DateTime @default(now()) @map("created_at")

  user      Profile  @relation("UserReposts", fields: [userId], references: [userId], onDelete: Cascade)
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@index([userId, createdAt])
  @@map("reposts")
}

model Follow {
  id          String   @id @default(uuid())
  followerId  String   @map("follower_id")
  followingId String   @map("following_id")

  createdAt   DateTime @default(now()) @map("created_at")

  follower    Profile  @relation("Following", fields: [followerId], references: [userId], onDelete: Cascade)
  following   Profile  @relation("Followers", fields: [followingId], references: [userId], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

// DJ Sessions & Rooms Enhancement

enum SessionStatus {
  ACTIVE
  PAUSED
  ENDED
}

model DJSession {
  id              String        @id @default(uuid())
  name            String?       // Session name
  isPrivate       Boolean       @default(false) @map("is_private") // Privacy setting
  roomId          String?       @map("room_id")
  hostId          String        @map("host_id")
  currentDJId     String        @map("current_dj_id")
  status          SessionStatus @default(ACTIVE)
  nowPlayingRef   Json?         @map("now_playing_ref") // Current track metadata
  nowPlayingStart DateTime?     @map("now_playing_start")
  genre           String        @default("Other") // Music genre for the session
  tags            String[]      @default([]) // Tags to describe session vibe

  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @updatedAt @map("updated_at")
  endedAt         DateTime?     @map("ended_at")

  room            Room?         @relation(fields: [roomId], references: [id], onDelete: Cascade)
  host            User          @relation("SessionHost", fields: [hostId], references: [id], onDelete: Cascade)
  currentDJ       User          @relation("CurrentDJ", fields: [currentDJId], references: [id], onDelete: Cascade)
  queue           QueueItem[]

  @@index([roomId])
  @@index([hostId])
  @@index([currentDJId])
  @@index([status])
  @@index([isPrivate])
  @@index([genre])
  @@map("dj_sessions")
}

model QueueItem {
  id        String   @id @default(uuid())
  sessionId String   @map("session_id")
  addedBy   String   @map("added_by")
  trackRef  Json     @map("track_ref") // Track metadata
  position  Int
  upvotes   Int      @default(0)
  downvotes Int      @default(0)

  createdAt DateTime @default(now()) @map("created_at")
  playedAt  DateTime? @map("played_at")
  skipped   Boolean  @default(false)

  session   DJSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  votes     Vote[]

  @@unique([sessionId, position])
  @@index([sessionId, position])
  @@map("queue_items")
}

enum VoteType {
  UPVOTE
  DOWNVOTE
}

model Vote {
  id          String   @id @default(uuid())
  queueItemId String   @map("queue_item_id")
  userId      String   @map("user_id")
  voteType    VoteType @map("vote_type")

  createdAt   DateTime @default(now()) @map("created_at")

  queueItem   QueueItem @relation(fields: [queueItemId], references: [id], onDelete: Cascade)

  @@unique([queueItemId, userId])
  @@index([queueItemId])
  @@map("votes")
}

// Progression System Models

model UserProgression {
  id            String   @id @default(uuid())
  userId        String   @unique @map("user_id")
  level         Int      @default(1)
  xp            Int      @default(0)
  totalXP       Int      @default(0) @map("total_xp")

  // Streaks
  currentStreak Int      @default(0) @map("current_streak")
  longestStreak Int      @default(0) @map("longest_streak")
  lastActivity  DateTime @default(now()) @map("last_activity")

  // Stats
  tracksPlayed       Int @default(0) @map("tracks_played")
  totalListeningTime Int @default(0) @map("total_listening_time") // seconds
  postsCreated       Int @default(0) @map("posts_created")
  commentsCreated    Int @default(0) @map("comments_created")
  cratesCreated      Int @default(0) @map("crates_created")
  artistsDiscovered  Int @default(0) @map("artists_discovered")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user          Profile @relation("UserProgressionProfile", fields: [userId], references: [userId], onDelete: Cascade)
  badgeUnlocks  UserBadge[]

  @@index([level])
  @@index([totalXP])
  @@map("user_progression")
}

enum BadgeRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
}

enum BadgeCategory {
  ACTIVITY
  SOCIAL
  CURATOR
  DISCOVERY
  SPECIAL
}

model Badge {
  id             String        @id @default(uuid())
  name           String
  description    String
  icon           String        // Icon name or URL
  rarity         BadgeRarity
  category       BadgeCategory
  requirementKey String        @map("requirement_key") // e.g., "tracks_played"
  requirementValue Int         @map("requirement_value") // e.g., 100

  createdAt      DateTime      @default(now()) @map("created_at")

  unlocks        UserBadge[]

  @@unique([requirementKey, requirementValue])
  @@map("badges")
}

model UserBadge {
  id         String   @id @default(uuid())
  userId     String   @map("user_id")
  badgeId    String   @map("badge_id")
  unlockedAt DateTime @default(now()) @map("unlocked_at")

  user        Profile         @relation("UserBadgeProfile", fields: [userId], references: [userId], onDelete: Cascade, map: "user_badges_profile_fkey")
  badge       Badge           @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  progression UserProgression @relation(fields: [userId], references: [userId], onDelete: Cascade, map: "user_badges_progression_fkey")

  @@unique([userId, badgeId])
  @@index([userId])
  @@map("user_badges")
}

// AI Detection Models

enum AIDetectionStatus {
  PENDING
  ANALYZING
  VERIFIED_HUMAN
  FLAGGED_AI
  UNDER_REVIEW
  REJECTED
}

model AIDetectionResult {
  id        String             @id @default(uuid())
  trackRef  Json               @map("track_ref") // Track metadata
  uploadedBy String            @map("uploaded_by")
  status    AIDetectionStatus @default(PENDING)
  riskScore Float?             @map("risk_score") // 0-100

  detectionData Json?           @map("detection_data") // AI service response
  moderatorNotes String?        @map("moderator_notes")
  reviewedBy String?            @map("reviewed_by")
  reviewedAt DateTime?          @map("reviewed_at")

  createdAt DateTime           @default(now()) @map("created_at")
  updatedAt DateTime           @updatedAt @map("updated_at")

  @@index([uploadedBy, status])
  @@index([status, riskScore])
  @@map("ai_detection_results")
}

model CommunityReport {
  id        String   @id @default(uuid())
  trackRef  Json     @map("track_ref")
  reportedBy String  @map("reported_by")
  reason    String
  description String?

  createdAt DateTime @default(now()) @map("created_at")

  @@index([reportedBy])
  @@map("community_reports")
}

// Messaging Models

model Conversation {
  id           String    @id @default(uuid())
  participantIds String[] @map("participant_ids") // Array of user IDs

  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")

  messages     DirectMessage[]

  @@index([participantIds])
  @@map("conversations")
}

model DirectMessage {
  id             String       @id @default(uuid())
  conversationId String       @map("conversation_id")
  senderId       String       @map("sender_id")
  content        String

  readBy         String[]     @default([]) @map("read_by") // Array of user IDs

  createdAt      DateTime     @default(now()) @map("created_at")
  updatedAt      DateTime     @updatedAt @map("updated_at")

  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
  @@index([senderId])
  @@map("direct_messages")
}

// Marketplace Models - Artist Dashboard

enum ProductType {
  DIGITAL_TRACK
  DIGITAL_ALBUM
  MERCHANDISE_LINK
  CONCERT_LINK
  PRESET_PACK
  SAMPLE_PACK
}

enum ProductStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum PurchaseStatus {
  PENDING
  COMPLETED
  REFUNDED
  FAILED
}

// Order fulfillment status for physical products (merch, concert tickets)
enum OrderStatus {
  PENDING_FULFILLMENT  // Payment complete, awaiting processing
  PROCESSING           // Order being prepared
  SHIPPED              // Order shipped (tracking info available)
  DELIVERED            // Order delivered
  CANCELLED            // Order cancelled
}

model MarketplaceProduct {
  id          String        @id @default(uuid())
  artistId    String        @map("artist_id")
  type        ProductType
  status      ProductStatus @default(DRAFT)

  // Basic info
  title       String
  description String?
  price       Float         // in USD
  coverImage  String?       @map("cover_image")

  // Track-specific (when type is DIGITAL_TRACK or DIGITAL_ALBUM)
  trackRef    Json?         @map("track_ref") // Track metadata
  fileUrl     String?       @map("file_url") // Download URL for digital products
  fileSize    Int?          @map("file_size") // in bytes

  // External link products (when type is MERCHANDISE_LINK or CONCERT_LINK)
  externalUrl String?       @map("external_url")
  externalPlatform String?  @map("external_platform") // e.g., "Bandcamp", "Ticketmaster"

  // Pack-specific (when type is PRESET_PACK or SAMPLE_PACK)
  packContents Json?        @map("pack_contents") // Array of file metadata

  // Stats
  viewCount     Int         @default(0) @map("view_count")
  purchaseCount Int         @default(0) @map("purchase_count")

  createdAt   DateTime      @default(now()) @map("created_at")
  updatedAt   DateTime      @updatedAt @map("updated_at")
  publishedAt DateTime?     @map("published_at")

  artist      User          @relation("ArtistProducts", fields: [artistId], references: [id], onDelete: Cascade)
  purchases   Purchase[]
  posts       Post[]        @relation("ProductPosts")
  messages    Message[]

  @@index([artistId, status])
  @@index([type, status])
  @@index([createdAt])
  @@map("marketplace_products")
}

model Purchase {
  id          String         @id @default(uuid())
  productId   String         @map("product_id")
  buyerId     String         @map("buyer_id")

  amount      Float          // Price at time of purchase
  status      PurchaseStatus @default(PENDING)

  // Payment details
  paymentMethod   String?    @map("payment_method") // e.g., "stripe", "paypal"
  paymentIntentId String?    @map("payment_intent_id")

  // Download tracking for digital products
  downloadCount   Int        @default(0) @map("download_count")
  lastDownloadAt  DateTime?  @map("last_download_at")

  // Shipping info for physical products (merch, concert tickets)
  orderStatus       OrderStatus?  @map("order_status")
  shippingName      String?       @map("shipping_name")
  shippingAddress1  String?       @map("shipping_address_1")
  shippingAddress2  String?       @map("shipping_address_2")
  shippingCity      String?       @map("shipping_city")
  shippingState     String?       @map("shipping_state")
  shippingZip       String?       @map("shipping_zip")
  shippingCountry   String?       @map("shipping_country")
  shippingPhone     String?       @map("shipping_phone")

  // Order fulfillment tracking
  trackingNumber    String?       @map("tracking_number")
  trackingCarrier   String?       @map("tracking_carrier") // e.g., "USPS", "UPS", "FedEx"
  shippedAt         DateTime?     @map("shipped_at")
  deliveredAt       DateTime?     @map("delivered_at")

  // Buyer notes (e.g., special instructions, size selection)
  buyerNotes        String?       @map("buyer_notes")
  productVariant    String?       @map("product_variant") // e.g., "Size: L, Color: Black"

  createdAt   DateTime       @default(now()) @map("created_at")
  updatedAt   DateTime       @updatedAt @map("updated_at")
  completedAt DateTime?      @map("completed_at")

  product     MarketplaceProduct @relation(fields: [productId], references: [id], onDelete: Cascade)
  buyer       User               @relation("UserPurchases", fields: [buyerId], references: [id], onDelete: Cascade)

  @@index([productId])
  @@index([buyerId, createdAt])
  @@index([status])
  @@index([orderStatus])
  @@map("purchases")
}

model ArtistRevenue {
  id          String   @id @default(uuid())
  artistId    String   @map("artist_id")

  // Revenue tracking
  totalRevenue     Float   @default(0) @map("total_revenue")
  pendingRevenue   Float   @default(0) @map("pending_revenue")
  withdrawnRevenue Float   @default(0) @map("withdrawn_revenue")

  // Period tracking
  currentMonth     Int     @map("current_month") // 1-12
  currentYear      Int     @map("current_year")
  monthlyRevenue   Float   @default(0) @map("monthly_revenue")

  // Stats
  totalSales       Int     @default(0) @map("total_sales")
  monthlySales     Int     @default(0) @map("monthly_sales")

  updatedAt   DateTime @updatedAt @map("updated_at")

  artist      User     @relation("ArtistRevenue", fields: [artistId], references: [id], onDelete: Cascade)

  @@unique([artistId, currentMonth, currentYear])
  @@index([artistId])
  @@map("artist_revenue")
}

model ArtistAnalytics {
  id          String   @id @default(uuid())
  artistId    String   @map("artist_id")

  // Date tracking
  date        DateTime @db.Date

  // Engagement metrics
  profileViews    Int @default(0) @map("profile_views")
  trackPlays      Int @default(0) @map("track_plays")
  trackShares     Int @default(0) @map("track_shares")
  newFollowers    Int @default(0) @map("new_followers")

  // Marketplace metrics
  productViews    Int @default(0) @map("product_views")
  productClicks   Int @default(0) @map("product_clicks")
  sales           Int @default(0)
  revenue         Float @default(0)

  // Geographic data (top countries)
  topCountries    Json? @map("top_countries") // Array of {country, count}

  createdAt   DateTime @default(now()) @map("created_at")

  artist      User     @relation("ArtistAnalytics", fields: [artistId], references: [id], onDelete: Cascade)

  @@unique([artistId, date])
  @@index([artistId, date])
  @@map("artist_analytics")
}

model FanEngagement {
  id          String   @id @default(uuid())
  artistId    String   @map("artist_id")
  fanId       String   @map("fan_id")

  // Engagement tracking
  totalPlays      Int      @default(0) @map("total_plays")
  totalPurchases  Int      @default(0) @map("total_purchases")
  totalSpent      Float    @default(0) @map("total_spent")

  lastEngagement  DateTime @default(now()) @map("last_engagement")
  firstEngagement DateTime @default(now()) @map("first_engagement")

  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  artist      User     @relation("ArtistFans", fields: [artistId], references: [id], onDelete: Cascade)
  fan         User     @relation("FanEngagements", fields: [fanId], references: [id], onDelete: Cascade)

  @@unique([artistId, fanId])
  @@index([artistId, lastEngagement])
  @@index([fanId])
  @@map("fan_engagements")
}

// Admin Portal Authentication

enum AdminRole {
  ADMIN
  SUPER_ADMIN
}

model AdminUser {
  id            String    @id @default(uuid())
  email         String    @unique
  passwordHash  String    @map("password_hash")
  name          String
  role          AdminRole @default(ADMIN)
  isActive      Boolean   @default(true) @map("is_active")

  lastLoginAt   DateTime? @map("last_login_at")
  lastLoginIp   String?   @map("last_login_ip")

  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  @@index([email])
  @@index([isActive])
  @@map("admin_users")
}

// Artist Payout History

enum PayoutStatus {
  PENDING
  IN_TRANSIT
  PAID
  FAILED
  CANCELED
}

model ArtistPayout {
  id          String       @id @default(uuid())
  artistId    String       @map("artist_id")

  // Stripe payout info
  stripePayoutId   String   @unique @map("stripe_payout_id")
  amount           Float    // Amount in dollars
  currency         String   @default("usd")
  status           PayoutStatus @default(PENDING)

  // Timing
  initiatedAt      DateTime @default(now()) @map("initiated_at")
  arrivalDate      DateTime? @map("arrival_date")
  completedAt      DateTime? @map("completed_at")

  // Failure info
  failureMessage   String?  @map("failure_message")

  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  artist      User     @relation("ArtistPayouts", fields: [artistId], references: [id], onDelete: Cascade)

  @@index([artistId, createdAt])
  @@index([status])
  @@map("artist_payouts")
}

// Streaming Service Connections (Spotify, Apple Music, etc.)

enum StreamingProvider {
  SPOTIFY
  APPLE_MUSIC
  TIDAL
}

model StreamingConnection {
  id          String            @id @default(uuid())
  userId      String            @map("user_id")
  provider    StreamingProvider

  // OAuth tokens (encrypted in practice)
  accessToken     String        @map("access_token")
  refreshToken    String?       @map("refresh_token")
  tokenExpiresAt  DateTime?     @map("token_expires_at")

  // Provider-specific user info
  providerUserId  String?       @map("provider_user_id")
  providerEmail   String?       @map("provider_email")
  displayName     String?       @map("display_name")
  profileImageUrl String?       @map("profile_image_url")
  country         String?       // User's country code
  productType     String?       @map("product_type") // e.g., "premium", "free"

  // Connection status
  isActive        Boolean       @default(true) @map("is_active")
  lastUsedAt      DateTime?     @map("last_used_at")
  lastRefreshedAt DateTime?     @map("last_refreshed_at")

  // Scopes granted
  scopes          String[]      @default([])

  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider])
  @@index([userId])
  @@index([provider])
  @@index([isActive])
  @@map("streaming_connections")
}

// Shopify Store Connection for Artists

enum ShopifyConnectionStatus {
  PENDING      // OAuth started but not completed
  CONNECTED    // Active connection
  DISCONNECTED // Manually disconnected
  EXPIRED      // Token expired
}

model ShopifyConnection {
  id          String                  @id @default(uuid())
  artistId    String                  @unique @map("artist_id")

  // Store info
  shopDomain  String                  @map("shop_domain") // e.g., "mystore.myshopify.com"
  shopName    String?                 @map("shop_name")

  // OAuth tokens (encrypted at rest)
  accessToken String                  @map("access_token")
  scopes      String[]                @default([])

  // OAuth state for CSRF protection (cleared after callback)
  oauthState  String?                 @map("oauth_state")

  // Connection status
  status      ShopifyConnectionStatus @default(PENDING)
  connectedAt DateTime?               @map("connected_at")

  // Sync tracking
  lastSyncedAt    DateTime?           @map("last_synced_at")
  lastSyncStatus  String?             @map("last_sync_status") // 'success', 'partial', 'failed'
  syncedProductCount Int              @default(0) @map("synced_product_count")

  createdAt   DateTime                @default(now()) @map("created_at")
  updatedAt   DateTime                @updatedAt @map("updated_at")

  artist      User                    @relation(fields: [artistId], references: [id], onDelete: Cascade)
  products    ShopifyProduct[]

  @@index([status])
  @@index([oauthState])
  @@map("shopify_connections")
}

// Cached Shopify Products (synced from Shopify)

model ShopifyProduct {
  id                String            @id @default(uuid())
  connectionId      String            @map("connection_id")
  shopifyProductId  String            @map("shopify_product_id")

  // Basic info (cached from Shopify)
  title             String
  description       String?
  productType       String?           @map("product_type")
  vendor            String?
  handle            String?           // URL handle

  // Pricing (first variant price)
  price             Float
  compareAtPrice    Float?            @map("compare_at_price")
  currency          String            @default("USD")

  // Media (cached)
  coverImage        String?           @map("cover_image")
  images            Json?             // Array of image URLs

  // Availability
  status            String            @default("active") // active, draft, archived
  availableForSale  Boolean           @default(true) @map("available_for_sale")
  totalInventory    Int?              @map("total_inventory")

  // Variants (cached)
  hasVariants       Boolean           @default(false) @map("has_variants")
  variants          Json?             // Array of variant objects

  // Tags and collections
  tags              String[]          @default([])
  collections       Json?             // Array of collection info

  // Sync tracking
  lastSyncedAt      DateTime          @map("last_synced_at")
  shopifyUpdatedAt  DateTime?         @map("shopify_updated_at")

  createdAt         DateTime          @default(now()) @map("created_at")
  updatedAt         DateTime          @updatedAt @map("updated_at")

  connection        ShopifyConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  @@unique([connectionId, shopifyProductId])
  @@index([connectionId, status])
  @@index([availableForSale])
  @@map("shopify_products")
}

// Merch Drops - Time-limited product releases

enum DropStatus {
  DRAFT       // Being created, not visible to fans
  SCHEDULED   // Set to go live at a future time
  LIVE        // Currently active
  ENDED       // Time window passed
  CANCELLED   // Manually cancelled
}

enum DropGatingType {
  PUBLIC                  // Anyone can access
  ROOM_ONLY               // Must be a room member
  FOLLOWERS_ONLY          // Only followers can access
  FOLLOWERS_EARLY_ACCESS  // Followers get early access
}

model MerchDrop {
  id          String        @id @default(uuid())
  artistId    String        @map("artist_id")

  // Basic info
  title       String
  description String?
  heroImage   String?       @map("hero_image")

  // Status
  status      DropStatus    @default(DRAFT)

  // Timing
  startsAt    DateTime?     @map("starts_at")
  endsAt      DateTime?     @map("ends_at")
  showCountdown Boolean     @default(true) @map("show_countdown")

  // Gating
  gatingType          DropGatingType  @default(PUBLIC) @map("gating_type")
  roomId              String?         @map("room_id") // Room ID for gating (ROOM_ONLY, FOLLOWERS_EARLY_ACCESS)
  earlyAccessDays     Int?            @map("early_access_days") // For FOLLOWERS_EARLY_ACCESS

  // Distribution settings
  showOnArtistPage    Boolean         @default(true) @map("show_on_artist_page")
  showInRoomFeed      Boolean         @default(false) @map("show_in_room_feed")
  showInSessions      Boolean         @default(false) @map("show_in_sessions")

  // Credits (future feature)
  allowCreditsDiscount Boolean        @default(false) @map("allow_credits_discount")
  maxCreditsPercent    Int?           @map("max_credits_percent")

  // Stats
  viewCount     Int           @default(0) @map("view_count")
  purchaseCount Int           @default(0) @map("purchase_count")
  totalRevenue  Float         @default(0) @map("total_revenue")

  // Timestamps
  publishedAt   DateTime?     @map("published_at")
  createdAt     DateTime      @default(now()) @map("created_at")
  updatedAt     DateTime      @updatedAt @map("updated_at")

  // Relations
  artist        User          @relation(fields: [artistId], references: [id], onDelete: Cascade)
  items         MerchDropItem[]

  @@index([artistId, status])
  @@index([status, startsAt])
  @@index([gatingType])
  @@map("merch_drops")
}

model MerchDropItem {
  id          String          @id @default(uuid())
  dropId      String          @map("drop_id")

  // Product reference (can be native or Shopify)
  productId   String          @map("product_id")
  provider    String          @default("native") // 'native' or 'shopify'

  // Display order
  sortOrder   Int             @default(0) @map("sort_order")

  // Optional drop-specific overrides
  customPrice       Float?    @map("custom_price")
  customTitle       String?   @map("custom_title")
  maxQuantityPerUser Int?     @map("max_quantity_per_user")

  // Stats for this item in this drop
  viewCount     Int           @default(0) @map("view_count")
  purchaseCount Int           @default(0) @map("purchase_count")

  createdAt   DateTime        @default(now()) @map("created_at")
  updatedAt   DateTime        @updatedAt @map("updated_at")

  drop        MerchDrop       @relation(fields: [dropId], references: [id], onDelete: Cascade)

  @@unique([dropId, productId, provider])
  @@index([dropId, sortOrder])
  @@map("merch_drop_items")
}