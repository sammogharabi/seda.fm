generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum VerificationStatus {
  PENDING
  CRAWLING
  AWAITING_ADMIN
  APPROVED
  DENIED
  EXPIRED
}

enum UserRole {
  USER
  ARTIST
  ADMIN
  SUPER_ADMIN
}

enum MessageType {
  TEXT
  TRACK_CARD
  SYSTEM
  REPLY
}

enum RoomMemberRole {
  MEMBER
  ADMIN
}

enum ModerationAction {
  DELETE_MESSAGE
  MUTE_USER
  CLEAR_REACTIONS
}

model User {
  id                    String                 @id @default(uuid())
  email                 String                 @unique
  supabaseId           String                 @unique @map("supabase_id")
  role                 UserRole               @default(USER)
  createdAt            DateTime               @default(now()) @map("created_at")
  updatedAt            DateTime               @updatedAt @map("updated_at")

  // Email verification
  emailVerified        Boolean                @default(false) @map("email_verified")
  emailVerificationToken String?              @unique @map("email_verification_token")
  emailVerificationTokenExpiresAt DateTime?  @map("email_verification_token_expires_at")
  userType             String?                @map("user_type") // 'fan' or 'artist'

  artistProfile        ArtistProfile?
  verificationRequests VerificationRequest[]
  reviewedVerifications VerificationRequest[] @relation("ReviewedVerifications")
  adminActions         AdminAction[]

  // Chat relations
  createdRooms         Room[]             @relation("RoomCreator")
  messages             Message[]
  reactions            Reaction[]
  roomMemberships      RoomMembership[]
  mutedUntil           DateTime?          @map("muted_until")

  // Wave A relations
  profile              Profile?

  // DJ Session relations
  hostedSessions       DJSession[] @relation("SessionHost")
  djSessions           DJSession[] @relation("CurrentDJ")

  // Marketplace relations
  products             MarketplaceProduct[] @relation("ArtistProducts")
  purchases            Purchase[]           @relation("UserPurchases")
  revenueRecords       ArtistRevenue[]      @relation("ArtistRevenue")
  analytics            ArtistAnalytics[]    @relation("ArtistAnalytics")
  fans                 FanEngagement[]      @relation("ArtistFans")
  fanEngagements       FanEngagement[]      @relation("FanEngagements")

  @@map("users")
}

model ArtistProfile {
  id           String   @id @default(uuid())
  userId       String   @unique @map("user_id")
  artistName   String   @map("artist_name")
  bio          String?
  verified     Boolean  @default(false)
  verifiedAt   DateTime? @map("verified_at")
  websiteUrl   String?  @map("website_url")
  spotifyUrl   String?  @map("spotify_url")
  bandcampUrl  String?  @map("bandcamp_url")
  soundcloudUrl String? @map("soundcloud_url")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // AI Detection & Trust
  trustedUploader     Boolean  @default(false) @map("trusted_uploader")
  trustedUploaderSince DateTime? @map("trusted_uploader_since")
  uploadCount         Int      @default(0) @map("upload_count")
  verifiedUploadCount Int      @default(0) @map("verified_upload_count")

  // Stripe Connect for payouts
  stripeAccountId     String?  @map("stripe_account_id")
  stripeAccountStatus String?  @map("stripe_account_status") // pending, active, restricted

  // PayPal for payouts
  paypalEmail         String?  @map("paypal_email")
  paypalMerchantId    String?  @map("paypal_merchant_id")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([verified])
  @@index([artistName])
  @@index([stripeAccountId])
  @@map("artist_profiles")
}

model VerificationRequest {
  id              String             @id @default(uuid())
  userId          String             @map("user_id")
  claimCode       String             @unique @map("claim_code")
  targetUrl       String?            @map("target_url")
  status          VerificationStatus @default(PENDING)
  submittedAt     DateTime           @default(now()) @map("submitted_at")
  expiresAt       DateTime           @map("expires_at")
  crawledAt       DateTime?          @map("crawled_at")
  reviewedAt      DateTime?          @map("reviewed_at")
  reviewedBy      String?            @map("reviewed_by")
  denialReason    String?            @map("denial_reason")
  crawlerResponse Json?              @map("crawler_response")
  metadata        Json?

  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  reviewer User?  @relation("ReviewedVerifications", fields: [reviewedBy], references: [id])

  @@index([status])
  @@index([userId])
  @@index([claimCode])
  @@index([expiresAt])
  @@map("verification_requests")
}

model AdminAction {
  id          String   @id @default(uuid())
  adminId     String   @map("admin_id")
  action      String
  targetId    String?  @map("target_id")
  targetType  String?  @map("target_type")
  details     Json?
  ipAddress   String?  @map("ip_address")
  userAgent   String?  @map("user_agent")
  createdAt   DateTime @default(now()) @map("created_at")

  admin User @relation(fields: [adminId], references: [id])

  @@index([adminId])
  @@index([targetId])
  @@index([createdAt])
  @@map("admin_actions")
}

model CrawlerCache {
  id         String   @id @default(uuid())
  url        String   @unique
  content    String?
  statusCode Int?     @map("status_code")
  headers    Json?
  crawledAt  DateTime @default(now()) @map("crawled_at")
  expiresAt  DateTime @map("expires_at")

  @@index([url])
  @@index([expiresAt])
  @@map("crawler_cache")
}

// Chat Models

model Room {
  id             String   @id @default(uuid())
  name           String
  description    String?
  isPrivate      Boolean  @default(false) @map("is_private")
  genre          String?
  coverImageUrl  String?  @map("cover_image_url")
  createdBy      String   @map("created_by")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  creator        User     @relation("RoomCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  messages       Message[]
  memberships    RoomMembership[]
  djSessions     DJSession[]

  @@index([isPrivate])
  @@index([createdAt])
  @@index([createdBy])
  @@map("rooms")
}

model RoomMembership {
  id       String           @id @default(uuid())
  roomId   String           @map("room_id")
  userId   String           @map("user_id")
  role     RoomMemberRole   @default(MEMBER)
  joinedAt DateTime         @default(now()) @map("joined_at")

  room Room @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([roomId, userId])
  @@index([roomId])
  @@index([userId])
  @@map("room_memberships")
}

model Message {
  id        String      @id @default(uuid())
  roomId    String      @map("room_id")
  userId    String      @map("user_id")
  type      MessageType @default(TEXT)
  text      String?
  trackRef  Json?       @map("track_ref")
  parentId  String?     @map("parent_id")
  createdAt DateTime    @default(now()) @map("created_at")
  updatedAt DateTime    @updatedAt @map("updated_at")
  deletedAt DateTime?   @map("deleted_at")
  
  room      Room        @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent    Message?    @relation("MessageReplies", fields: [parentId], references: [id])
  replies   Message[]   @relation("MessageReplies")
  reactions Reaction[]

  @@index([roomId, createdAt])
  @@index([userId])
  @@index([parentId])
  @@index([deletedAt])
  @@map("messages")
}

model Reaction {
  id        String   @id @default(uuid())
  messageId String   @map("message_id")
  userId    String   @map("user_id")
  emoji     String
  createdAt DateTime @default(now()) @map("created_at")
  
  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@index([userId])
  @@map("reactions")
}

model TrackRef {
  id         String   @id @default(uuid())
  provider   String   // spotify, apple, youtube, bandcamp, beatport
  providerId String   @map("provider_id")
  url        String   @unique
  title      String
  artist     String
  artwork    String?
  duration   Int?     // in seconds
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")
  
  @@unique([provider, providerId])
  @@index([provider])
  @@index([url])
  @@map("track_refs")
}

// Wave A Models - Profiles & Playlists

model Profile {
  id          String   @id @default(uuid())
  userId      String   @unique @map("user_id")
  username    String   @unique
  displayName String?  @map("display_name")
  bio         String?
  avatarUrl   String?  @map("avatar_url")

  // Onboarding fields
  genres              String[] @default([])
  genresCompleted     Boolean  @default(false) @map("genres_completed")
  genresCompletedAt   DateTime? @map("genres_completed_at")

  // Artist profile customization fields
  coverImage          String?  @map("cover_image")
  location            String?  // e.g., "Brooklyn, NY"
  photos              Json?    // Array of {id, url, caption}
  videos              Json?    // Array of {id, url, title, thumbnail}

  // Highlighted content (JSON arrays)
  highlightedTracks    Json? @map("highlighted_tracks")    // Array of track refs
  highlightedMerch     Json? @map("highlighted_merch")     // Array of product refs
  highlightedConcerts  Json? @map("highlighted_concerts")  // Array of concert refs

  // Social links (additional to ArtistProfile)
  instagramUrl        String?  @map("instagram_url")
  youtubeUrl          String?  @map("youtube_url")
  websiteUrl          String?  @map("website_url")

  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  user                User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  ownedPlaylists      Playlist[]             @relation("PlaylistOwner")
  playlistCollaborations PlaylistCollaborator[]
  addedPlaylistItems  PlaylistItem[]

  // Social Feed Relations
  posts          Post[]    @relation("UserPosts")
  comments       Comment[] @relation("UserComments")
  likes          Like[]    @relation("UserLikes")
  reposts        Repost[]  @relation("UserReposts")
  following      Follow[]  @relation("Following")
  followers      Follow[]  @relation("Followers")

  // Progression Relations
  progression    UserProgression? @relation("UserProgressionProfile")
  badgeUnlocks   UserBadge[]      @relation("UserBadgeProfile")

  @@index([username])
  @@index([genresCompleted])
  @@map("profiles")
}

model Playlist {
  id              String   @id @default(uuid())
  ownerUserId     String   @map("owner_user_id")
  title           String
  description     String?
  isPublic        Boolean  @default(true) @map("is_public")
  isCollaborative Boolean  @default(false) @map("is_collaborative")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Crate social features
  coverImageUrl String?  @map("cover_image_url")
  genre         String?
  mood          String?
  tags          String[] @default([])
  playCount     Int      @default(0) @map("play_count")

  owner        Profile                @relation("PlaylistOwner", fields: [ownerUserId], references: [userId], onDelete: Cascade)
  items        PlaylistItem[]
  collaborators PlaylistCollaborator[]

  // Social relations
  posts         Post[]  @relation("CratePosts")
  likes         Like[]  @relation("CrateLikes")

  @@index([ownerUserId])
  @@index([isPublic])
  @@map("playlists")
}

model PlaylistCollaborator {
  playlistId String   @map("playlist_id")
  userId     String   @map("user_id")
  role       String   @default("contributor") // contributor, editor, owner
  addedAt    DateTime @default(now()) @map("added_at")

  playlist Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  profile  Profile  @relation(fields: [userId], references: [userId], onDelete: Cascade)

  @@id([playlistId, userId])
  @@map("playlist_collaborators")
}

model PlaylistItem {
  id               String   @id @default(uuid())
  playlistId       String   @map("playlist_id")
  position         Int
  provider         String   // spotify, apple, beatport, youtube, etc.
  providerTrackId  String   @map("provider_track_id")
  title            String?  // optional denormalization
  artist           String?  // optional denormalization
  artworkUrl       String?  @map("artwork_url")
  addedByUserId    String   @map("added_by_user_id")
  addedAt          DateTime @default(now()) @map("added_at")

  playlist  Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  addedBy   Profile  @relation(fields: [addedByUserId], references: [userId], onDelete: Cascade)

  @@unique([playlistId, position])
  @@index([playlistId])
  @@index([addedByUserId])
  @@map("playlist_items")
}

model ModerationLog {
  id         String           @id @default(uuid())
  roomId     String           @map("room_id")
  moderatorId String          @map("moderator_id")
  targetId   String           @map("target_id") // message or user id
  action     ModerationAction
  reason     String?
  createdAt  DateTime         @default(now()) @map("created_at")

  @@index([roomId])
  @@index([moderatorId])
  @@index([targetId])
  @@index([createdAt])
  @@map("moderation_logs")
}

// Social Feed Models

enum PostType {
  TEXT
  TRACK
  CRATE
  MEDIA
}

model Post {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  type      PostType
  content   String?  // Text content
  trackRef  Json?    @map("track_ref") // Track metadata if type=TRACK
  crateId   String?  @map("crate_id")  // If type=CRATE
  mediaUrls String[] @map("media_urls") // If type=MEDIA

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at")

  user      Profile  @relation("UserPosts", fields: [userId], references: [userId], onDelete: Cascade)
  crate     Playlist? @relation("CratePosts", fields: [crateId], references: [id], onDelete: SetNull)
  comments  Comment[]
  likes     Like[]
  reposts   Repost[]

  @@index([userId, createdAt])
  @@index([type])
  @@index([deletedAt])
  @@map("posts")
}

model Comment {
  id        String    @id @default(uuid())
  postId    String    @map("post_id")
  userId    String    @map("user_id")
  parentId  String?   @map("parent_id") // For threading
  content   String

  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at")

  post      Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      Profile   @relation("UserComments", fields: [userId], references: [userId], onDelete: Cascade)
  parent    Comment?  @relation("CommentReplies", fields: [parentId], references: [id])
  replies   Comment[] @relation("CommentReplies")
  likes     Like[]

  @@index([postId, createdAt])
  @@index([userId])
  @@index([parentId])
  @@map("comments")
}

enum LikeableType {
  POST
  COMMENT
  CRATE
}

model Like {
  id        String       @id @default(uuid())
  userId    String       @map("user_id")
  type      LikeableType
  postId    String?      @map("post_id")
  commentId String?      @map("comment_id")
  crateId   String?      @map("crate_id")

  createdAt DateTime     @default(now()) @map("created_at")

  user      Profile      @relation("UserLikes", fields: [userId], references: [userId], onDelete: Cascade)
  post      Post?        @relation(fields: [postId], references: [id], onDelete: Cascade)
  comment   Comment?     @relation(fields: [commentId], references: [id], onDelete: Cascade)
  crate     Playlist?    @relation("CrateLikes", fields: [crateId], references: [id], onDelete: Cascade)

  @@unique([userId, type, postId])
  @@unique([userId, type, commentId])
  @@unique([userId, type, crateId])
  @@index([postId])
  @@index([commentId])
  @@index([crateId])
  @@map("likes")
}

model Repost {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  postId    String   @map("post_id")

  createdAt DateTime @default(now()) @map("created_at")

  user      Profile  @relation("UserReposts", fields: [userId], references: [userId], onDelete: Cascade)
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@index([userId, createdAt])
  @@map("reposts")
}

model Follow {
  id          String   @id @default(uuid())
  followerId  String   @map("follower_id")
  followingId String   @map("following_id")

  createdAt   DateTime @default(now()) @map("created_at")

  follower    Profile  @relation("Following", fields: [followerId], references: [userId], onDelete: Cascade)
  following   Profile  @relation("Followers", fields: [followingId], references: [userId], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

// DJ Sessions & Rooms Enhancement

enum SessionStatus {
  ACTIVE
  PAUSED
  ENDED
}

model DJSession {
  id              String        @id @default(uuid())
  name            String?       // Session name
  isPrivate       Boolean       @default(false) @map("is_private") // Privacy setting
  roomId          String?       @map("room_id")
  hostId          String        @map("host_id")
  currentDJId     String        @map("current_dj_id")
  status          SessionStatus @default(ACTIVE)
  nowPlayingRef   Json?         @map("now_playing_ref") // Current track metadata
  nowPlayingStart DateTime?     @map("now_playing_start")
  genre           String        @default("Other") // Music genre for the session
  tags            String[]      @default([]) // Tags to describe session vibe

  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @updatedAt @map("updated_at")
  endedAt         DateTime?     @map("ended_at")

  room            Room?         @relation(fields: [roomId], references: [id], onDelete: Cascade)
  host            User          @relation("SessionHost", fields: [hostId], references: [id], onDelete: Cascade)
  currentDJ       User          @relation("CurrentDJ", fields: [currentDJId], references: [id], onDelete: Cascade)
  queue           QueueItem[]

  @@index([roomId])
  @@index([hostId])
  @@index([currentDJId])
  @@index([status])
  @@index([isPrivate])
  @@index([genre])
  @@map("dj_sessions")
}

model QueueItem {
  id        String   @id @default(uuid())
  sessionId String   @map("session_id")
  addedBy   String   @map("added_by")
  trackRef  Json     @map("track_ref") // Track metadata
  position  Int
  upvotes   Int      @default(0)
  downvotes Int      @default(0)

  createdAt DateTime @default(now()) @map("created_at")
  playedAt  DateTime? @map("played_at")
  skipped   Boolean  @default(false)

  session   DJSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  votes     Vote[]

  @@unique([sessionId, position])
  @@index([sessionId, position])
  @@map("queue_items")
}

enum VoteType {
  UPVOTE
  DOWNVOTE
}

model Vote {
  id          String   @id @default(uuid())
  queueItemId String   @map("queue_item_id")
  userId      String   @map("user_id")
  voteType    VoteType @map("vote_type")

  createdAt   DateTime @default(now()) @map("created_at")

  queueItem   QueueItem @relation(fields: [queueItemId], references: [id], onDelete: Cascade)

  @@unique([queueItemId, userId])
  @@index([queueItemId])
  @@map("votes")
}

// Progression System Models

model UserProgression {
  id            String   @id @default(uuid())
  userId        String   @unique @map("user_id")
  level         Int      @default(1)
  xp            Int      @default(0)
  totalXP       Int      @default(0) @map("total_xp")

  // Streaks
  currentStreak Int      @default(0) @map("current_streak")
  longestStreak Int      @default(0) @map("longest_streak")
  lastActivity  DateTime @default(now()) @map("last_activity")

  // Stats
  tracksPlayed       Int @default(0) @map("tracks_played")
  totalListeningTime Int @default(0) @map("total_listening_time") // seconds
  postsCreated       Int @default(0) @map("posts_created")
  commentsCreated    Int @default(0) @map("comments_created")
  cratesCreated      Int @default(0) @map("crates_created")
  artistsDiscovered  Int @default(0) @map("artists_discovered")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user          Profile @relation("UserProgressionProfile", fields: [userId], references: [userId], onDelete: Cascade)
  badgeUnlocks  UserBadge[]

  @@index([level])
  @@index([totalXP])
  @@map("user_progression")
}

enum BadgeRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
}

enum BadgeCategory {
  ACTIVITY
  SOCIAL
  CURATOR
  DISCOVERY
  SPECIAL
}

model Badge {
  id             String        @id @default(uuid())
  name           String
  description    String
  icon           String        // Icon name or URL
  rarity         BadgeRarity
  category       BadgeCategory
  requirementKey String        @map("requirement_key") // e.g., "tracks_played"
  requirementValue Int         @map("requirement_value") // e.g., 100

  createdAt      DateTime      @default(now()) @map("created_at")

  unlocks        UserBadge[]

  @@unique([requirementKey, requirementValue])
  @@map("badges")
}

model UserBadge {
  id         String   @id @default(uuid())
  userId     String   @map("user_id")
  badgeId    String   @map("badge_id")
  unlockedAt DateTime @default(now()) @map("unlocked_at")

  user        Profile         @relation("UserBadgeProfile", fields: [userId], references: [userId], onDelete: Cascade, map: "user_badges_profile_fkey")
  badge       Badge           @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  progression UserProgression @relation(fields: [userId], references: [userId], onDelete: Cascade, map: "user_badges_progression_fkey")

  @@unique([userId, badgeId])
  @@index([userId])
  @@map("user_badges")
}

// AI Detection Models

enum AIDetectionStatus {
  PENDING
  ANALYZING
  VERIFIED_HUMAN
  FLAGGED_AI
  UNDER_REVIEW
  REJECTED
}

model AIDetectionResult {
  id        String             @id @default(uuid())
  trackRef  Json               @map("track_ref") // Track metadata
  uploadedBy String            @map("uploaded_by")
  status    AIDetectionStatus @default(PENDING)
  riskScore Float?             @map("risk_score") // 0-100

  detectionData Json?           @map("detection_data") // AI service response
  moderatorNotes String?        @map("moderator_notes")
  reviewedBy String?            @map("reviewed_by")
  reviewedAt DateTime?          @map("reviewed_at")

  createdAt DateTime           @default(now()) @map("created_at")
  updatedAt DateTime           @updatedAt @map("updated_at")

  @@index([uploadedBy, status])
  @@index([status, riskScore])
  @@map("ai_detection_results")
}

model CommunityReport {
  id        String   @id @default(uuid())
  trackRef  Json     @map("track_ref")
  reportedBy String  @map("reported_by")
  reason    String
  description String?

  createdAt DateTime @default(now()) @map("created_at")

  @@index([reportedBy])
  @@map("community_reports")
}

// Messaging Models

model Conversation {
  id           String    @id @default(uuid())
  participantIds String[] @map("participant_ids") // Array of user IDs

  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")

  messages     DirectMessage[]

  @@index([participantIds])
  @@map("conversations")
}

model DirectMessage {
  id             String       @id @default(uuid())
  conversationId String       @map("conversation_id")
  senderId       String       @map("sender_id")
  content        String

  readBy         String[]     @default([]) @map("read_by") // Array of user IDs

  createdAt      DateTime     @default(now()) @map("created_at")
  updatedAt      DateTime     @updatedAt @map("updated_at")

  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
  @@index([senderId])
  @@map("direct_messages")
}

// Marketplace Models - Artist Dashboard

enum ProductType {
  DIGITAL_TRACK
  DIGITAL_ALBUM
  MERCHANDISE_LINK
  CONCERT_LINK
  PRESET_PACK
  SAMPLE_PACK
}

enum ProductStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum PurchaseStatus {
  PENDING
  COMPLETED
  REFUNDED
  FAILED
}

model MarketplaceProduct {
  id          String        @id @default(uuid())
  artistId    String        @map("artist_id")
  type        ProductType
  status      ProductStatus @default(DRAFT)

  // Basic info
  title       String
  description String?
  price       Float         // in USD
  coverImage  String?       @map("cover_image")

  // Track-specific (when type is DIGITAL_TRACK or DIGITAL_ALBUM)
  trackRef    Json?         @map("track_ref") // Track metadata
  fileUrl     String?       @map("file_url") // Download URL for digital products
  fileSize    Int?          @map("file_size") // in bytes

  // External link products (when type is MERCHANDISE_LINK or CONCERT_LINK)
  externalUrl String?       @map("external_url")
  externalPlatform String?  @map("external_platform") // e.g., "Bandcamp", "Ticketmaster"

  // Pack-specific (when type is PRESET_PACK or SAMPLE_PACK)
  packContents Json?        @map("pack_contents") // Array of file metadata

  // Stats
  viewCount     Int         @default(0) @map("view_count")
  purchaseCount Int         @default(0) @map("purchase_count")

  createdAt   DateTime      @default(now()) @map("created_at")
  updatedAt   DateTime      @updatedAt @map("updated_at")
  publishedAt DateTime?     @map("published_at")

  artist      User          @relation("ArtistProducts", fields: [artistId], references: [id], onDelete: Cascade)
  purchases   Purchase[]

  @@index([artistId, status])
  @@index([type, status])
  @@index([createdAt])
  @@map("marketplace_products")
}

model Purchase {
  id          String         @id @default(uuid())
  productId   String         @map("product_id")
  buyerId     String         @map("buyer_id")

  amount      Float          // Price at time of purchase
  status      PurchaseStatus @default(PENDING)

  // Payment details
  paymentMethod   String?    @map("payment_method") // e.g., "stripe", "paypal"
  paymentIntentId String?    @map("payment_intent_id")

  // Download tracking for digital products
  downloadCount   Int        @default(0) @map("download_count")
  lastDownloadAt  DateTime?  @map("last_download_at")

  createdAt   DateTime       @default(now()) @map("created_at")
  updatedAt   DateTime       @updatedAt @map("updated_at")
  completedAt DateTime?      @map("completed_at")

  product     MarketplaceProduct @relation(fields: [productId], references: [id], onDelete: Cascade)
  buyer       User               @relation("UserPurchases", fields: [buyerId], references: [id], onDelete: Cascade)

  @@index([productId])
  @@index([buyerId, createdAt])
  @@index([status])
  @@map("purchases")
}

model ArtistRevenue {
  id          String   @id @default(uuid())
  artistId    String   @map("artist_id")

  // Revenue tracking
  totalRevenue     Float   @default(0) @map("total_revenue")
  pendingRevenue   Float   @default(0) @map("pending_revenue")
  withdrawnRevenue Float   @default(0) @map("withdrawn_revenue")

  // Period tracking
  currentMonth     Int     @map("current_month") // 1-12
  currentYear      Int     @map("current_year")
  monthlyRevenue   Float   @default(0) @map("monthly_revenue")

  // Stats
  totalSales       Int     @default(0) @map("total_sales")
  monthlySales     Int     @default(0) @map("monthly_sales")

  updatedAt   DateTime @updatedAt @map("updated_at")

  artist      User     @relation("ArtistRevenue", fields: [artistId], references: [id], onDelete: Cascade)

  @@unique([artistId, currentMonth, currentYear])
  @@index([artistId])
  @@map("artist_revenue")
}

model ArtistAnalytics {
  id          String   @id @default(uuid())
  artistId    String   @map("artist_id")

  // Date tracking
  date        DateTime @db.Date

  // Engagement metrics
  profileViews    Int @default(0) @map("profile_views")
  trackPlays      Int @default(0) @map("track_plays")
  trackShares     Int @default(0) @map("track_shares")
  newFollowers    Int @default(0) @map("new_followers")

  // Marketplace metrics
  productViews    Int @default(0) @map("product_views")
  productClicks   Int @default(0) @map("product_clicks")
  sales           Int @default(0)
  revenue         Float @default(0)

  // Geographic data (top countries)
  topCountries    Json? @map("top_countries") // Array of {country, count}

  createdAt   DateTime @default(now()) @map("created_at")

  artist      User     @relation("ArtistAnalytics", fields: [artistId], references: [id], onDelete: Cascade)

  @@unique([artistId, date])
  @@index([artistId, date])
  @@map("artist_analytics")
}

model FanEngagement {
  id          String   @id @default(uuid())
  artistId    String   @map("artist_id")
  fanId       String   @map("fan_id")

  // Engagement tracking
  totalPlays      Int      @default(0) @map("total_plays")
  totalPurchases  Int      @default(0) @map("total_purchases")
  totalSpent      Float    @default(0) @map("total_spent")

  lastEngagement  DateTime @default(now()) @map("last_engagement")
  firstEngagement DateTime @default(now()) @map("first_engagement")

  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  artist      User     @relation("ArtistFans", fields: [artistId], references: [id], onDelete: Cascade)
  fan         User     @relation("FanEngagements", fields: [fanId], references: [id], onDelete: Cascade)

  @@unique([artistId, fanId])
  @@index([artistId, lastEngagement])
  @@index([fanId])
  @@map("fan_engagements")
}

// Admin Portal Authentication

enum AdminRole {
  ADMIN
  SUPER_ADMIN
}

model AdminUser {
  id            String    @id @default(uuid())
  email         String    @unique
  passwordHash  String    @map("password_hash")
  name          String
  role          AdminRole @default(ADMIN)
  isActive      Boolean   @default(true) @map("is_active")

  lastLoginAt   DateTime? @map("last_login_at")
  lastLoginIp   String?   @map("last_login_ip")

  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  @@index([email])
  @@index([isActive])
  @@map("admin_users")
}